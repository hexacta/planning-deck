<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="hx-card.html">

<dom-module id="hx-deck">
  <template>
    <style include="shared-styles">
       :host {
        display: block;
        padding: 10px;
      }
      
      .deck {
        height: 350px;
        width: 250px;
        border: solid 2px red;
      }
      
      hx-card {
        position: absolute;
        transform-origin: bottom left;
        /*transition: transform 0.1s ease-in-out;*/
      }
    </style>

    <div class="deck" on-track="handleTrack">
      <template is="dom-repeat" items="[[cards]]">
        <hx-card card-index="[[index]]">[[item]]</hx-card>
      </template>
    </div>
  </template>

  <script>
    class HxDeck extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() { return 'hx-deck'; }

      static get properties() {
        return {
          cards: {
            type: Array,
            value: () => [1, 2, 3, 5, 8, 13, 21]
          }
        }
      }

      ready() {
        super.ready();
        this.currentIndex = this.cards.length - 1;
      }

      get currentCard() {
        return this.shadowRoot.querySelector(`.deck hx-card:nth-child(${this.currentIndex + 1})`);
      }

      handleTrack(e) {
        const dx = e.detail.dx;

        let card = this.currentCard;

        switch (e.detail.state) {
          case 'start':
            const targetIndex = e.target.cardIndex;
            if (targetIndex && targetIndex > this.currentIndex) {
              this.currentIndex += 1;
            }
            card = this.currentCard;
            this.cardWidth = card.getBoundingClientRect().width;
            card.style.transition = '';
            break;
          case 'track':
            if (dx < this.cardWidth / 2) {
              card.style.transform = `translateX(${dx}px)`;
            } else {
              const hdx = dx - this.cardWidth / 2;
              const pdx = hdx / this.cardWidth;
              const rotation = pdx * 90;
              card.style.transform = `translateX(50%) rotate(${rotation}deg)`;
            }
            break;
          case 'end':
            if (e.detail.dx < this.cardWidth / 2) {
              card.style.transition = 'transform 0.5s ease-in-out';
              card.style.transform = 'translateX(0px)';
            } else {
              const rotation = 12 + this.currentIndex * 2;
              card.style.transition = 'transform 0.2s ease-in-out';
              card.style.transform = `translateX(50%) rotate(${rotation}deg)`;
              this.currentIndex -= 1;
            }
            break;
        }
      }

      startDrag(e) {
        const targetIndex = e.target.cardIndex;

        const toLeft = targetIndex && targetIndex > this.currentIndex;
        const toRight = !toLeft;
        const emptyDeck = this.currentIndex < 0;

        if (toRight && emptyDeck) {
          return;
        }

        const draggingIndex = toLeft ? this.curentIndex + 1 : this.currentIndex;

        this.draggingCard = this.shadowRoot.querySelector(`.deck hx-card:nth-child(${draggingIndex + 1})`);
        this.draggingDirection = toLeft ? "left" : "right";
        this.cardWidth = this.draggingCard.getBoundingClientRect().width;
        this.draggingCard.style.transition = '';
      }

      drag(e) {
        if (!this.draggingCard) return;

        const dx = e.detail.dx;
        if (this.draggingDirection === "right") {
          if (dx < this.cardWidth / 2) {
            this.draggingCard.style.transform = `translateX(${dx}px)`;
          } else {
            const hdx = dx - this.cardWidth / 2;
            const pdx = hdx / this.cardWidth;
            const rotation = pdx * 90;
            this.draggingCard.style.transform = `translateX(50%) rotate(${rotation}deg)`;
          }
        } else {
          const threshold = (this.cardWidth * (12 + (this.currentIndex + 1) * 2) / 90);
          if (dx < -threshold) {
            // const rotation = 12 + this.currentIndex * 2;
            const pdx = -dx / threshold;
            const rotation = (12 + (this.currentIndex + 1) * 2) * pdx * 90;
            this.draggingCard.style.transform = `translateX(50%) rotate(${rotation}deg)`;
          } else {
            const pdx = (this.cardWidth / 2) - (threshold + dx);
            this.draggingCard.style.transform = `translateX(${pdx}px)`;
          }

        }
      }

      stopDrag(e) {
        if (!this.draggingCard) return;

        if (this.draggingDirection === "right") {
          if (e.detail.dx < this.cardWidth / 2) {
            this.draggingCard.style.transition = 'transform 0.5s ease-in-out';
            this.draggingCard.style.transform = 'translateX(0px)';
          } else {
            const rotation = 12 + this.currentIndex * 2;
            this.draggingCard.style.transition = 'transform 0.2s ease-in-out';
            this.draggingCard.style.transform = `translateX(50%) rotate(${rotation}deg)`;
            this.currentIndex -= 1;
          }
        } else {
          if (e.detail.dx < -this.cardWidth / 2) {
            const rotation = 12 + this.currentIndex * 2;
            this.draggingCard.style.transition = 'transform 0.2s ease-in-out';
            this.draggingCard.style.transform = `translateX(50%) rotate(${rotation}deg)`;
          } else {
            this.draggingCard.style.transition = 'transform 0.5s ease-in-out';
            this.draggingCard.style.transform = 'translateX(0px)';
            this.currentIndex += 1;
          }
        }

        this.draggingDirection = null;
        this.draggingCard = null;
      }

    }

    window.requestAnimationFramePromise = _ => new Promise(requestAnimationFrame);
    window.customElements.define(HxDeck.is, HxDeck);
  </script>
</dom-module>