<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="hx-card.html">

<dom-module id="hx-deck">
  <template>
    <style include="shared-styles">
       :host {
        display: block;
        padding: 10px;
      }
      
      .deck {
        height: 350px;
        width: 250px;
        border: solid 2px red;
        overflow: hidden;
        cursor: grab;
        cursor: -moz-grab;
        cursor: -webkit-grab;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      
      .deck:active {
        cursor: grabbing;
        cursor: -moz-grabbing;
        cursor: -webkit-grabbing;
      }
      
      hx-card {
        position: absolute;
        transform-origin: bottom left;
        /*transition: transform 0.1s ease-in-out;*/
      }
    </style>

    <div class="deck" on-track="handleTrack">
      <template is="dom-repeat" items="[[cards]]">
        <hx-card card-index="[[index]]" value="[[item]]"></hx-card>
      </template>
    </div>
  </template>

  <script>
    class HxDeck extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() { return 'hx-deck'; }

      static get properties() {
        return {
          cards: {
            type: Array,
            value: () => [1, 2, 3, 5, 8, 13, 21]
          }
        }
      }

      getCard(index) {
        return this.shadowRoot.querySelector(`.deck hx-card:nth-child(${index + 1})`);
      }

      ready() {
        super.ready();
        this.currentIndex = this.cards.length - 1;
      }

      handleTrack(e) {
        const dx = e.detail.dx;

        switch (e.detail.state) {
          case 'start':
            this.startDrag(e);
            break;
          case 'track':
            this.drag(e);
            break;
          case 'end':
            this.stopDrag(e);
            break;
        }
      }

      startDrag(e) {
        const targetIndex = e.target.cardIndex;

        const toLeft = targetIndex && targetIndex > this.currentIndex;
        const toRight = !toLeft;
        const emptyDeck = this.currentIndex < 0;

        if (toRight && emptyDeck) {
          return;
        }

        const draggingIndex = toLeft ? this.currentIndex + 1 : this.currentIndex;

        if (toRight) {
          this.cardWidth = this.getCard(draggingIndex).getBoundingClientRect().width;
        }

        this.draggingCard = this.getCard(draggingIndex);
        this.draggingDirection = toLeft ? "left" : "right";
        this.draggingCard.style.transition = '';
      }

      drag(e) {
        if (!this.draggingCard) return;

        const transform = this.getTransform(e.detail.dx, this.draggingDirection, this.currentIndex, this.cardWidth);
        this.draggingCard.style.transform = transform;
      }

      stopDrag(e) {
        if (!this.draggingCard) return;
        const halfWidth = this.cardWidth / 2;
        const toRight = this.draggingDirection === "right";
        const toLeft = !toRight;
        const x = this.getX(e.detail.dx, this.draggingDirection, this.currentIndex, this.cardWidth);
        const translate = x < halfWidth ? 0 : halfWidth;
        const rotate = x < halfWidth ? 0 : this.getRestAngle(this.draggingDirection, this.currentIndex);

        this.draggingCard.style.transform = this.toCSS(translate, rotate);
        this.draggingCard.style.transition = 'transform 0.25s ease-in-out';

        if (toRight && x >= halfWidth) {
          this.currentIndex -= 1;
        } else if (toLeft && x < halfWidth) {
          this.currentIndex += 1;
        }

        this.draggingDirection = null;
        this.draggingCard = null;
      }

      getTransform(dx, direction, currentIndex, cardWidth) {
        const halfWidth = cardWidth / 2;
        const x = this.getX(dx, direction, currentIndex, cardWidth);

        const translate = Math.min(x, halfWidth);
        const angle = 90 * (x - halfWidth) / halfWidth;
        const rotate = Math.max(0, angle);

        return this.toCSS(translate, rotate);
      }

      getX(dx, direction, currentIndex, cardWidth) {
        const toRight = direction === "right";
        const restAngle = this.getRestAngle(direction, currentIndex);
        const halfWidth = cardWidth / 2;
        const restX = halfWidth + (restAngle / 90) * halfWidth;
        return toRight ? dx : restX + dx;
      }

      getRestAngle(direction, currentIndex) {
        const toRight = direction === "right";
        const draggingIndex = toRight ? currentIndex : currentIndex + 1;
        return 12 + draggingIndex * 2;
      }

      toCSS(translate, rotate) {
        return `translateX(${translate}px) rotate(${rotate}deg)`;
      }
    }

    // window.requestAnimationFramePromise = () => new Promise(requestAnimationFrame);
    window.customElements.define(HxDeck.is, HxDeck);
  </script>
</dom-module>