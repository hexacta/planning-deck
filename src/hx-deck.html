<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="hx-card.html">

<dom-module id="hx-deck">
  <template>
    <style include="shared-styles">
       :host {
        display: block;
        padding: 10px;
      }
      
      .deck {
        height: 350px;
        width: 250px;
        border: solid 2px red;
        overflow: hidden;

        cursor: grab;
        cursor: -moz-grab;
        cursor: -webkit-grab;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      .deck:active {
        cursor: grabbing;
        cursor: -moz-grabbing;
        cursor: -webkit-grabbing;
      }
      
      hx-card {
        position: absolute;
        transform-origin: bottom left;
        /*transition: transform 0.1s ease-in-out;*/
      }
    </style>

    <div class="deck" on-track="handleTrack">
      <template is="dom-repeat" items="[[cards]]">
        <hx-card card-index="[[index]]" value="[[item]]"></hx-card>
      </template>
    </div>
  </template>

  <script>
    class HxDeck extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() { return 'hx-deck'; }

      static get properties() {
        return {
          cards: {
            type: Array,
            value: () => [1, 2, 3, 5, 8, 13, 21]
          }
        }
      }

      getCard(index) {
        return this.shadowRoot.querySelector(`.deck hx-card:nth-child(${index + 1})`);
      }

      ready() {
        super.ready();
        this.currentIndex = this.cards.length - 1;
      }

      handleTrack(e) {
        const dx = e.detail.dx;

        let card = this.currentCard;

        switch (e.detail.state) {
          case 'start':
            this.startDrag(e);
            break;
          case 'track':
            this.drag(e);
            break;
          case 'end':
            this.stopDrag(e);
            break;
        }
      }

      startDrag(e) {
        const targetIndex = e.target.cardIndex;

        const toLeft = targetIndex && targetIndex > this.currentIndex;
        const toRight = !toLeft;
        const emptyDeck = this.currentIndex < 0;

        if (toRight && emptyDeck) {
          return;
        }

        const draggingIndex = toLeft ? this.currentIndex + 1 : this.currentIndex;

        if (toRight) {
          this.cardWidth = this.getCard(draggingIndex).getBoundingClientRect().width;
        }

        this.draggingCard = this.getCard(draggingIndex);
        this.draggingDirection = toLeft ? "left" : "right";
        this.draggingCard.style.transition = '';
      }

      drag(e) {
        if (!this.draggingCard) return;

        const dx = e.detail.dx;
        if (this.draggingDirection === "right") {
          if (dx < this.cardWidth / 2) {
            this.draggingCard.style.transform = `translateX(${dx}px)`;
          } else {
            const hdx = dx - this.cardWidth / 2;
            const pdx = hdx / this.cardWidth;
            const rotation = pdx * 90;
            this.draggingCard.style.transform = `translateX(50%) rotate(${rotation}deg)`;
          }
        } else {
          const startAngle = 12 + (this.currentIndex + 1) * 2;
          const startX = this.cardWidth / 2 + (startAngle / 90) * (this.cardWidth / 2);
          const x = startX + dx;
          // console.log(x, dx);
          if (x < this.cardWidth / 2) {
            console.log(this.cardWidth, x);
            this.draggingCard.style.transform = `translateX(${x}px)`;
          } else {
            const hdx = x - this.cardWidth / 2;
            const pdx = hdx / this.cardWidth;
            const rotation = pdx * 90;
            this.draggingCard.style.transform = `translateX(50%) rotate(${rotation}deg)`;
          }

        }
      }

      stopDrag(e) {
        if (!this.draggingCard) return;

        if (this.draggingDirection === "right") {
          if (e.detail.dx < this.cardWidth / 2) {
            this.draggingCard.style.transition = 'transform 0.5s ease-in-out';
            this.draggingCard.style.transform = 'translateX(0px)';
          } else {
            const rotation = 12 + this.currentIndex * 2;
            this.draggingCard.style.transition = 'transform 0.2s ease-in-out';
            this.draggingCard.style.transform = `translateX(50%) rotate(${rotation}deg)`;
            this.currentIndex -= 1;
          }
        } else {
          if (e.detail.dx < -this.cardWidth / 2) {
            const rotation = 12 + this.currentIndex * 2;
            this.draggingCard.style.transition = 'transform 0.2s ease-in-out';
            this.draggingCard.style.transform = `translateX(50%) rotate(${rotation}deg)`;
          } else {
            this.draggingCard.style.transition = 'transform 0.5s ease-in-out';
            this.draggingCard.style.transform = 'translateX(0px)';
            this.currentIndex += 1;
          }
        }

        this.draggingDirection = null;
        this.draggingCard = null;
      }

    }

    window.requestAnimationFramePromise = _ => new Promise(requestAnimationFrame);
    window.customElements.define(HxDeck.is, HxDeck);
  </script>
</dom-module>