<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="hx-card.html">
<link rel="import" href="dragging.html">

<dom-module id="hx-deck">
  <template>
    <style>
       :host {
        display: block;
        height: 100%;
        width: 100%;
      }
      
      .deck {
        position: relative;
        height: 100%;
        width: 100%;
        max-width: 400px;
        margin: auto;
        background-color: #666;
        /*rgb(10, 172, 142)*/
        overflow: hidden;
        cursor: grab;
        cursor: -moz-grab;
        cursor: -webkit-grab;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      
      .deck:active {
        cursor: grabbing;
        cursor: -moz-grabbing;
        cursor: -webkit-grabbing;
      }
      
      .card {
        position: absolute;
        transform-origin: 25% 175%;
        /* See https://codepen.io/pomber/pen/mWvXqz */
        width: 70%;
        left: 15%;
        bottom: -5px;
        will-change: transform;
        /*transition: transform 0.1s ease-in-out;*/
      }
      
      .card:before {
        content: "";
        float: left;
        padding-bottom: 140%;
      }
      
      .card:after {
        content: "";
        display: table;
        clear: both;
      }
    </style>

    <div class="deck" on-track="handleTrack">
      <template is="dom-repeat" items="[[cards]]">
        <hx-card card-index="[[index]]" value="[[item.value]]" name="[[item.name]]" class="card"></hx-card>
      </template>
    </div>
  </template>

  <script>
    class HxDeck extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() { return 'hx-deck'; }

      static get properties() {
        return {
          cards: {
            type: Array,
            value: () => [
              { value: "?", name: "unknown" },
              { value: 0, name: "zero" },
              { value: "Â½", name: "half" },
              { value: 1, name: "one" },
              { value: 2, name: "two" },
              { value: 3, name: "three" },
              { value: 5, name: "five" },
              { value: 8, name: "eight" },
              { value: 13, name: "thirteen" },
              { value: 21, name: "twenty one" },
            ]
          }
        }
      }

      getCard(index) {
        return this.shadowRoot.querySelector(`.deck hx-card:nth-child(${index + 1})`);
      }

      ready() {
        super.ready();
        this.currentIndex = this.cards.length - 1;
      }

      handleTrack(e) {
        if (e.detail.state === "start") {
          const targetIndex = e.target.cardIndex;

          const toLeft = targetIndex && targetIndex > this.currentIndex;
          const toRight = !toLeft;
          const emptyDeck = this.currentIndex < 0;

          if (toRight && emptyDeck) {
            return;
          }

          const draggingIndex = toLeft ? this.currentIndex + 1 : this.currentIndex;

          this.draggingCard = this.getCard(draggingIndex);
        }

        if (!this.draggingCard) return;

        const card = this.draggingCard;
        const newState = Hx.move(e, card.state || {
          rest: "middle",
          index: card.cardIndex,
          cardHeight: card.getBoundingClientRect().height
        });

        if (e.detail.state == "start") {
          requestAnimationFrame(() => {
            this.update(card);
          });
        }

        if (e.detail.state == "end") {
          this.draggingCard = null;
          if (card.state.rest != "right" && newState.rest == "right") {
            this.currentIndex--;
          }
          if (card.state.rest == "right" && newState.rest != "right") {
            this.currentIndex++;
          }
        }

        card.state = newState;
      }

      update(card) {
        card.style.transform = card.state.transform;
        card.style.transition = card.state.transition;
        card.style.transformOrigin = card.state.transformOrigin || "";
        card.style.zIndex = card.state.zIndex || "";;

        if (card.state.endState) {
          card.addEventListener("transitionend", () => {
            card.state = Object.assign({}, card.state, card.state.endState);
            this.update(card);
          }, { once: true });
        }

        if (this.draggingCard) {
          requestAnimationFrame(() => {
            this.update(card);
          });
        }
      }

    }

    window.customElements.define(HxDeck.is, HxDeck);
  </script>
</dom-module>